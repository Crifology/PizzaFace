{"version":3,"file":"waveform-data.min.js","sources":["../src/waveform-data-channel.js","../src/waveform-generator.js","../src/waveform-data.js","../src/waveform-utils.js"],"sourcesContent":["/**\n * Provides access to the waveform data for a single audio channel.\n */\n\nfunction WaveformDataChannel(waveformData, channelIndex) {\n  this._waveformData = waveformData;\n  this._channelIndex = channelIndex;\n}\n\n/**\n * Returns the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.min_sample = function(index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Returns the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.max_sample = function(index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Sets the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_min_sample = function(index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Sets the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_max_sample = function(index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Returns all the waveform minimum values as an array.\n */\n\nWaveformDataChannel.prototype.min_array = function() {\n  return this._waveformData._offsetValues(\n    0,\n    this._waveformData.length,\n    this._channelIndex * 2\n  );\n};\n\n/**\n * Returns all the waveform maximum values as an array.\n */\n\nWaveformDataChannel.prototype.max_array = function() {\n  return this._waveformData._offsetValues(\n    0,\n    this._waveformData.length,\n    this._channelIndex * 2 + 1\n  );\n};\n\nexport default WaveformDataChannel;\n","/**\n * AudioBuffer-based WaveformData generator\n *\n * Adapted from BlockFile::CalcSummary in Audacity, with permission.\n * See https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/BlockFile.cpp\n */\n\n var INT8_MAX = 127;\n var INT8_MIN = -128;\n\n function calculateWaveformDataLength(audio_sample_count, scale) {\n   var data_length = Math.floor(audio_sample_count / scale);\n\n   var samples_remaining = audio_sample_count - (data_length * scale);\n\n   if (samples_remaining > 0) {\n     data_length++;\n   }\n\n   return data_length;\n }\n\nfunction generateWaveformData(options) {\n  var scale = options.scale;\n  var amplitude_scale = options.amplitude_scale;\n  var split_channels = options.split_channels;\n  var length = options.length;\n  var sample_rate = options.sample_rate;\n  var channels = options.channels.map(function(channel) {\n    return new Float32Array(channel);\n  });\n  var output_channels = split_channels ? channels.length : 1;\n  var version = output_channels === 1 ? 1 : 2;\n  var header_size = version === 1 ? 20 : 24;\n  var data_length = calculateWaveformDataLength(length, scale);\n  var total_size = header_size + data_length * 2 * output_channels;\n  var buffer = new ArrayBuffer(total_size);\n  var data_view = new DataView(buffer);\n\n  var scale_counter = 0;\n  var offset = header_size;\n  var channel, i;\n\n  var min_value = new Array(output_channels);\n  var max_value = new Array(output_channels);\n\n  for (channel = 0; channel < output_channels; channel++) {\n    min_value[channel] = Infinity;\n    max_value[channel] = -Infinity;\n  }\n\n  data_view.setInt32(0, version, true); // Version\n  data_view.setUint32(4, 1, true); // Is 8 bit?\n  data_view.setInt32(8, sample_rate, true); // Sample rate\n  data_view.setInt32(12, scale, true); // Scale\n  data_view.setInt32(16, data_length, true); // Length\n\n  if (version === 2) {\n    data_view.setInt32(20, output_channels, true);\n  }\n\n  for (i = 0; i < length; i++) {\n    var sample = 0;\n\n    if (output_channels === 1) {\n      for (channel = 0; channel < channels.length; ++channel) {\n        sample += channels[channel][i];\n      }\n\n      sample = Math.floor(INT8_MAX * sample * amplitude_scale / channels.length);\n\n      if (sample < min_value[0]) {\n        min_value[0] = sample;\n\n        if (min_value[0] < INT8_MIN) {\n          min_value[0] = INT8_MIN;\n        }\n      }\n\n      if (sample > max_value[0]) {\n        max_value[0] = sample;\n\n        if (max_value[0] > INT8_MAX) {\n          max_value[0] = INT8_MAX;\n        }\n      }\n    }\n    else {\n      for (channel = 0; channel < output_channels; ++channel) {\n        sample = Math.floor(INT8_MAX * channels[channel][i] * amplitude_scale);\n\n        if (sample < min_value[channel]) {\n          min_value[channel] = sample;\n\n          if (min_value[channel] < INT8_MIN) {\n            min_value[channel] = INT8_MIN;\n          }\n        }\n\n        if (sample > max_value[channel]) {\n          max_value[channel] = sample;\n\n          if (max_value[channel] > INT8_MAX) {\n            max_value[channel] = INT8_MAX;\n          }\n        }\n      }\n    }\n\n    if (++scale_counter === scale) {\n      for (channel = 0; channel < output_channels; channel++) {\n        data_view.setInt8(offset++, min_value[channel]);\n        data_view.setInt8(offset++, max_value[channel]);\n\n        min_value[channel] = Infinity;\n        max_value[channel] = -Infinity;\n      }\n\n      scale_counter = 0;\n    }\n  }\n\n  if (scale_counter > 0) {\n    for (channel = 0; channel < output_channels; channel++) {\n      data_view.setInt8(offset++, min_value[channel]);\n      data_view.setInt8(offset++, max_value[channel]);\n    }\n  }\n\n  return buffer;\n}\n\nexport { generateWaveformData };\n","import WaveformDataChannel from \"./waveform-data-channel\";\nimport { generateWaveformData } from \"./waveform-generator\";\nimport { isJsonWaveformData, isBinaryWaveformData, convertJsonToBinary } from \"./waveform-utils\";\nimport WaveformDataWorker from \"web-worker:./waveform-data-worker\";\n\n/**\n * Provides access to waveform data.\n */\n\nfunction WaveformData(data) {\n  if (isJsonWaveformData(data)) {\n    data = convertJsonToBinary(data);\n  }\n\n  if (isBinaryWaveformData(data)) {\n    this._data = new DataView(data);\n    this._offset = this._version() === 2 ? 24 : 20;\n\n    this._channels = [];\n\n    for (var channel = 0; channel < this.channels; channel++) {\n      this._channels[channel] = new WaveformDataChannel(this, channel);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"WaveformData.create(): Unknown data format\"\n    );\n  }\n}\n\nvar defaultOptions = {\n  scale: 512,\n  amplitude_scale: 1.0,\n  split_channels: false,\n  disable_worker: false\n};\n\nfunction getOptions(options) {\n  var opts = {\n    scale: options.scale || defaultOptions.scale,\n    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,\n    split_channels: options.split_channels || defaultOptions.split_channels,\n    disable_worker: options.disable_worker || defaultOptions.disable_worker\n  };\n\n  return opts;\n}\n\nfunction getChannelData(audio_buffer) {\n  var channels = [];\n\n  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {\n    channels.push(audio_buffer.getChannelData(i).buffer);\n  }\n\n  return channels;\n}\n\nfunction createFromAudioBuffer(audio_buffer, options, callback) {\n  var channels = getChannelData(audio_buffer);\n\n  if (options.disable_worker) {\n    var buffer = generateWaveformData({\n      scale: options.scale,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    });\n\n    callback(null, new WaveformData(buffer), audio_buffer);\n  }\n  else {\n    var worker = new WaveformDataWorker();\n\n    worker.onmessage = function(evt) {\n      callback(null, new WaveformData(evt.data), audio_buffer);\n    };\n\n    worker.postMessage({\n      scale: options.scale,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    }, channels);\n  }\n}\n\nfunction createFromArrayBuffer(audioContext, audioData, options, callback) {\n  // The following function is a workaround for a Webkit bug where decodeAudioData\n  // invokes the errorCallback with null instead of a DOMException.\n  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n  // and http://stackoverflow.com/q/10365335/103396\n\n  function errorCallback(error) {\n    if (!error) {\n      error = new DOMException(\"EncodingError\");\n    }\n\n    callback(error);\n  }\n\n  audioContext.decodeAudioData(\n    audioData,\n    function(audio_buffer) {\n      createFromAudioBuffer(audio_buffer, options, callback);\n    },\n    errorCallback\n  );\n}\n\n/**\n * Creates and returns a WaveformData instance from the given waveform data.\n */\n\nWaveformData.create = function create(data) {\n  return new WaveformData(data);\n};\n\n/**\n * Creates a WaveformData instance from audio.\n */\n\nWaveformData.createFromAudio = function(options, callback) {\n  var opts = getOptions(options);\n\n  if (options.audio_context && options.array_buffer) {\n    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);\n  }\n  else if (options.audio_buffer) {\n    return createFromAudioBuffer(options.audio_buffer, opts, callback);\n  }\n  else {\n    throw new TypeError(\n      // eslint-disable-next-line\n      \"WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object\"\n    );\n  }\n};\n\nWaveformData.prototype = {\n\n  /**\n   * Creates and returns a new WaveformData object with resampled data.\n   * Use this method to create waveform data at different zoom levels.\n   *\n   * Adapted from Sequence::GetWaveDisplay in Audacity, with permission.\n   * https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/Sequence.cpp\n   */\n\n  resample: function(options) {\n    options.scale = typeof options.scale === \"number\" ? options.scale : null;\n    options.width = typeof options.width === \"number\" ? options.width : null;\n\n    if (options.width != null && options.width <= 0) {\n      throw new RangeError(\"WaveformData.resample(): width should be a positive integer value\");\n    }\n\n    if (options.scale != null && options.scale <= 0) {\n      throw new RangeError(\"WaveformData.resample(): scale should be a positive integer value\");\n    }\n\n    if (!options.scale && !options.width) {\n      throw new Error(\"WaveformData.resample(): Missing scale or width option\");\n    }\n\n    // Scale we want to reach\n    var output_samples_per_pixel = options.scale ||\n      Math.floor(this.duration * this.sample_rate / options.width);\n    var scale = this.scale; // scale we are coming from\n\n    // The amount of data we want to resample i.e. final zoom want to resample\n    // all data but for intermediate zoom we want to resample subset\n    var input_buffer_size = this.length;\n\n    var input_buffer_length_samples = input_buffer_size * this.scale;\n    var output_buffer_length_samples =\n      Math.ceil(input_buffer_length_samples / output_samples_per_pixel);\n\n    var output_header_size = 24; // version 2\n    var bytes_per_sample = this.bits === 8 ? 1 : 2;\n    var total_size = output_header_size\n                   + output_buffer_length_samples * 2 * this.channels * bytes_per_sample;\n    var output_data = new ArrayBuffer(total_size);\n    var output_dataview = new DataView(output_data);\n\n    output_dataview.setInt32(0, 2, true); // Version\n    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?\n    output_dataview.setInt32(8, this.sample_rate, true);\n    output_dataview.setInt32(12, output_samples_per_pixel, true);\n    output_dataview.setInt32(16, output_buffer_length_samples, true);\n    output_dataview.setInt32(20, this.channels, true);\n\n    var waveform_data = new WaveformData(output_data);\n\n    var input_index = 0;\n    var output_index = 0;\n\n    var channels = this.channels;\n\n    var min = new Array(channels);\n    var max = new Array(channels);\n\n    var channel;\n\n    for (channel = 0; channel < channels; ++channel) {\n      if (input_buffer_size > 0) {\n        min[channel] = this.channel(channel).min_sample(input_index);\n        max[channel] = this.channel(channel).max_sample(input_index);\n      }\n      else {\n        min[channel] = 0;\n        max[channel] = 0;\n      }\n    }\n\n    var min_value = this.bits === 8 ? -128 : -32768;\n    var max_value = this.bits === 8 ?  127 :  32767;\n\n    if (output_samples_per_pixel < scale) {\n      throw new Error(\n        \"WaveformData.resample(): Zoom level \" + output_samples_per_pixel +\n        \" too low, minimum: \" + scale\n      );\n    }\n\n    var where, prev_where, stop, value, last_input_index;\n\n    function sample_at_pixel(x) {\n      return Math.floor(x * output_samples_per_pixel);\n    }\n\n    while (input_index < input_buffer_size) {\n      while (Math.floor(sample_at_pixel(output_index) / scale) === input_index) {\n        if (output_index > 0) {\n          for (channel = 0; channel < channels; ++channel) {\n            waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n            waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n          }\n        }\n\n        last_input_index = input_index;\n\n        output_index++;\n\n        where      = sample_at_pixel(output_index);\n        prev_where = sample_at_pixel(output_index - 1);\n\n        if (where !== prev_where) {\n          for (channel = 0; channel < channels; ++channel) {\n            min[channel] = max_value;\n            max[channel] = min_value;\n          }\n        }\n      }\n\n      where = sample_at_pixel(output_index);\n      stop = Math.floor(where / scale);\n\n      if (stop > input_buffer_size) {\n        stop = input_buffer_size;\n      }\n\n      while (input_index < stop) {\n        for (channel = 0; channel < channels; ++channel) {\n          value = this.channel(channel).min_sample(input_index);\n\n          if (value < min[channel]) {\n            min[channel] = value;\n          }\n\n          value = this.channel(channel).max_sample(input_index);\n\n          if (value > max[channel]) {\n            max[channel] = value;\n          }\n        }\n\n        input_index++;\n      }\n    }\n\n    if (input_index !== last_input_index) {\n      for (channel = 0; channel < channels; ++channel) {\n        waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n        waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n      }\n    }\n\n    return waveform_data;\n  },\n\n  /**\n   * Concatenates with one or more other waveforms, returning a new WaveformData object.\n   */\n\n  concat: function() {\n    var self = this;\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n\n    // Check that all the supplied waveforms are compatible\n    otherWaveforms.forEach(function(otherWaveform) {\n      if (self.channels !== otherWaveform.channels ||\n        self.sample_rate !== otherWaveform.sample_rate ||\n        self.bits !== otherWaveform.bits ||\n        self.scale !== otherWaveform.scale) {\n        throw new Error(\"WaveformData.concat(): Waveforms are incompatible\");\n      }\n    });\n\n    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);\n\n    return WaveformData.create(combinedBuffer);\n  },\n\n  /**\n   * Returns a new ArrayBuffer with the concatenated waveform.\n   * All waveforms must have identical metadata (version, channels, etc)\n   */\n\n  _concatBuffers: function() {\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n    var headerSize = this._offset;\n    var totalSize = headerSize;\n    var totalDataLength = 0;\n    var bufferCollection = [this].concat(otherWaveforms).map(function(w) {\n      return w._data.buffer;\n    });\n    var i, buffer;\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      var dataSize = new DataView(buffer).getInt32(16, true);\n\n      totalSize += buffer.byteLength - headerSize;\n      totalDataLength += dataSize;\n    }\n\n    var totalBuffer = new ArrayBuffer(totalSize);\n    var sourceHeader = new DataView(bufferCollection[0]);\n    var totalBufferView = new DataView(totalBuffer);\n\n    // Copy the header from the first chunk\n    for (i = 0; i < headerSize; i++) {\n      totalBufferView.setUint8(i, sourceHeader.getUint8(i));\n    }\n    // Rewrite the data-length header item to reflect all of the samples concatenated together\n    totalBufferView.setInt32(16, totalDataLength, true);\n\n    var offset = 0;\n    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);\n      offset += buffer.byteLength - headerSize;\n    }\n\n    return totalBuffer;\n  },\n\n  /**\n   * Return the unpacked values for a particular offset.\n   */\n\n  _offsetValues: function getOffsetValues(start, length, correction) {\n    var values = [];\n    var channels = this.channels;\n\n    correction += (start * channels * 2); // offset the positioning query\n\n    for (var i = 0; i < length; i++) {\n      values.push(this._at((i * channels * 2) + correction));\n    }\n\n    return values;\n  },\n\n  /**\n   * Returns the data format version number.\n   */\n\n  _version: function() {\n    return this._data.getInt32(0, true);\n  },\n\n  /**\n   * Returns the length of the waveform, in pixels.\n   */\n\n  get length() {\n    return this._data.getUint32(16, true);\n  },\n\n  /**\n   * Returns the number of bits per sample, either 8 or 16.\n   */\n\n  get bits() {\n    var bits = Boolean(this._data.getUint32(4, true));\n\n    return bits ? 8 : 16;\n  },\n\n  /**\n   * Returns the (approximate) duration of the audio file, in seconds.\n   */\n\n  get duration() {\n    return this.length * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of pixels per second.\n   */\n\n  get pixels_per_second() {\n    return this.sample_rate / this.scale;\n  },\n\n  /**\n   * Returns the amount of time represented by a single pixel, in seconds.\n   */\n\n  get seconds_per_pixel() {\n    return this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of waveform channels.\n   */\n\n  get channels() {\n    if (this._version() === 2) {\n      return this._data.getInt32(20, true);\n    }\n    else {\n      return 1;\n    }\n  },\n\n  /**\n   * Returns a waveform channel.\n   */\n\n  channel: function(index) {\n    if (index >= 0 && index < this._channels.length) {\n      return this._channels[index];\n    }\n    else {\n      throw new RangeError(\"Invalid channel: \" + index);\n    }\n  },\n\n  /**\n   * Returns the number of audio samples per second.\n   */\n\n  get sample_rate() {\n    return this._data.getInt32(8, true);\n  },\n\n  /**\n   * Returns the number of audio samples per pixel.\n   */\n\n  get scale() {\n    return this._data.getInt32(12, true);\n  },\n\n  /**\n   * Returns a waveform data value at a specific offset.\n   */\n\n  _at: function at_sample(index) {\n    if (this.bits === 8) {\n      return this._data.getInt8(this._offset + index);\n    }\n    else {\n      return this._data.getInt16(this._offset + index * 2, true);\n    }\n  },\n\n  /**\n   * Sets a waveform data value at a specific offset.\n   */\n\n  _set_at: function set_at(index, sample) {\n    if (this.bits === 8) {\n      return this._data.setInt8(this._offset + index, sample);\n    }\n    else {\n      return this._data.setInt16(this._offset + index * 2, sample, true);\n    }\n  },\n\n  /**\n   * Returns the waveform data index position for a given time.\n   */\n\n  at_time: function at_time(time) {\n    return Math.floor(time * this.sample_rate / this.scale);\n  },\n\n  /**\n   * Returns the time in seconds for a given index.\n   */\n\n  time: function time(index) {\n    return index * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns an object containing the waveform data.\n   */\n\n  toJSON: function() {\n    const waveform = {\n      version: 2,\n      channels: this.channels,\n      sample_rate: this.sample_rate,\n      samples_per_pixel: this.scale,\n      bits: this.bits,\n      length: this.length,\n      data: []\n    };\n\n    for (var i = 0; i < this.length; i++) {\n      for (var channel = 0; channel < this.channels; channel++) {\n        waveform.data.push(this.channel(channel).min_sample(i));\n        waveform.data.push(this.channel(channel).max_sample(i));\n      }\n    }\n\n    return waveform;\n  },\n\n  /**\n   * Returns the waveform data in binary format as an ArrayBuffer.\n   */\n\n  toArrayBuffer: function() {\n    return this._data.buffer;\n  }\n};\n\nexport default WaveformData;\n","export function isJsonWaveformData(data) {\n  return data &&\n    typeof data === \"object\" &&\n    \"sample_rate\" in data &&\n    \"samples_per_pixel\" in data &&\n    \"bits\" in data &&\n    \"length\" in data &&\n    \"data\" in data;\n}\n\nexport function isBinaryWaveformData(data) {\n  var isCompatible = data && typeof data === \"object\" && \"byteLength\" in data;\n\n  if (isCompatible) {\n    var view = new DataView(data);\n    var version = view.getInt32(0, true);\n\n    if (version !== 1 && version !== 2) {\n      throw new TypeError(\"WaveformData.create(): This waveform data version not supported\");\n    }\n  }\n\n  return isCompatible;\n}\n\nexport function convertJsonToBinary(data) {\n  var waveformData = data.data;\n  var channels = data.channels || 1;\n  var header_size = 24; // version 2\n  var bytes_per_sample = data.bits === 8 ? 1 : 2;\n  var expected_length = data.length * 2 * channels;\n\n  if (waveformData.length !== expected_length) {\n    throw new Error(\"WaveformData.create(): Length mismatch in JSON waveform data\");\n  }\n\n  var total_size = header_size + waveformData.length * bytes_per_sample;\n\n  var array_buffer = new ArrayBuffer(total_size);\n  var data_object = new DataView(array_buffer);\n\n  data_object.setInt32(0, 2, true); // Version\n  data_object.setUint32(4, data.bits === 8, true);\n  data_object.setInt32(8, data.sample_rate, true);\n  data_object.setInt32(12, data.samples_per_pixel, true);\n  data_object.setInt32(16, data.length, true);\n  data_object.setInt32(20, channels, true);\n\n  var index = header_size;\n\n  var i;\n\n  if (data.bits === 8) {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt8(index++, waveformData[i], true);\n    }\n  }\n  else {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt16(index, waveformData[i], true);\n\n      index += 2;\n    }\n  }\n\n  return array_buffer;\n}\n"],"names":["WaveformDataChannel","waveformData","channelIndex","_waveformData","_channelIndex","prototype","min_sample","index","offset","this","channels","_at","max_sample","set_min_sample","sample","_set_at","set_max_sample","min_array","_offsetValues","length","max_array","INT8_MAX","INT8_MIN","generateWaveformData","options","channel","i","scale","amplitude_scale","split_channels","sample_rate","map","Float32Array","output_channels","version","header_size","data_length","audio_sample_count","Math","floor","calculateWaveformDataLength","buffer","ArrayBuffer","data_view","DataView","scale_counter","min_value","Array","max_value","Infinity","setInt32","setUint32","setInt8","WaveformData","data","_typeof","isJsonWaveformData","bytes_per_sample","bits","expected_length","Error","total_size","array_buffer","data_object","samples_per_pixel","setInt16","convertJsonToBinary","isCompatible","getInt32","TypeError","isBinaryWaveformData","_data","_offset","_version","_channels","defaultOptions","createFromAudioBuffer","audio_buffer","callback","numberOfChannels","push","getChannelData","disable_worker","sampleRate","worker","WaveformDataWorker","onmessage","evt","postMessage","create","createFromAudio","opts","getOptions","audio_context","audioContext","audioData","decodeAudioData","error","DOMException","createFromArrayBuffer","resample","width","RangeError","output_samples_per_pixel","duration","input_buffer_size","input_buffer_length_samples","output_buffer_length_samples","ceil","output_data","output_dataview","waveform_data","input_index","output_index","min","max","where","stop","value","last_input_index","sample_at_pixel","x","concat","self","otherWaveforms","slice","call","arguments","forEach","otherWaveform","combinedBuffer","_concatBuffers","apply","headerSize","totalSize","totalDataLength","bufferCollection","w","dataSize","byteLength","totalBuffer","sourceHeader","totalBufferView","setUint8","getUint8","dataOfTotalBuffer","Uint8Array","set","start","correction","values","getUint32","Boolean","pixels_per_second","seconds_per_pixel","getInt8","getInt16","at_time","time","toJSON","waveform","toArrayBuffer"],"mappings":"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"}